"""I asked Gemini to analyze the log dump of all the websocket messages to come up with a schema.

Valid as of ComfyUI commit `daf9d25ee282051055e773185aa161cd2a1ce3a6`.
"""

from typing import Annotated, List, Literal, Optional, Union

from pydantic import BaseModel, Field, TypeAdapter

# --- Sub-Models for Data Payloads ---
# These models represent nested objects found within the 'data' field of messages.


class ExecInfo(BaseModel):
    """
    Execution information, part of the 'status' message, detailing the
    number of tasks remaining in the queue.
    """

    queue_remaining: int


class StatusInfo(BaseModel):
    """The 'status' object containing execution info."""

    exec_info: ExecInfo


class ImageOutput(BaseModel):
    """Represents a single image file generated by a node."""

    filename: str
    subfolder: str
    type: Literal["temp"]


class ExecutedOutput(BaseModel):
    """
    Represents the 'output' dictionary in an 'executed' message.
    The content varies depending on the node's function, such as generating
    images or other artifacts like 3D models.
    """

    images: Optional[List[ImageOutput]] = None
    result: Optional[List[Optional[str]]] = None


# --- Data Payload Models ---
# Each model corresponds to the 'data' field of a specific message type.


class StatusData(BaseModel):
    """Data payload for 'status' messages."""

    status: StatusInfo
    sid: Optional[str] = None


class ExecutingData(BaseModel):
    """Data payload for 'executing' messages. Some fields are optional as
    they appear to be added in different phases of the event."""

    node: Optional[str] = None
    prompt_id: Optional[str] = None
    display_node: Optional[str] = None


class ExecutionCachedData(BaseModel):
    """Data payload for 'execution_cached' messages, indicating that a set of
    nodes did not need to be re-executed."""

    nodes: List[str]
    prompt_id: str
    timestamp: int


class ExecutedData(BaseModel):
    """Data payload for 'executed' messages, sent when a node has finished
    its execution and produced an output."""

    node: str
    display_node: str
    prompt_id: str
    output: Optional[ExecutedOutput] = None


class ProgressData(BaseModel):
    """Data payload for 'progress' messages, indicating the progress of a
    long-running node execution (e.g., a sampler)."""

    value: int
    max: int
    prompt_id: str
    node: str


class ExecutionSuccessData(BaseModel):
    """Gemini didn't see this one cuz it wasn't in my log dump since my code exits by checking another message type..."""

    prompt_id: str


class ExecutionStartData(BaseModel):
    prompt_id: str
    timestamp: int


# --- Top-Level Message Models ---
# These models represent the entire message object, keyed by the 'type' field.


class StatusMessage(BaseModel):
    """A 'status' update message from the server."""

    type: Literal["status"]
    data: StatusData


class ExecutingMessage(BaseModel):
    """An 'executing' event message, signaling a node is starting its work."""

    type: Literal["executing"]
    data: ExecutingData


class ExecutionCachedMessage(BaseModel):
    """An 'execution_cached' event message."""

    type: Literal["execution_cached"]
    data: ExecutionCachedData


class ExecutedMessage(BaseModel):
    """An 'executed' event message, signaling a node has completed its work."""

    type: Literal["executed"]
    data: ExecutedData


class ProgressMessage(BaseModel):
    """A 'progress' update message from a node."""

    type: Literal["progress"]
    data: ProgressData


class ExecutionSuccessMessage(BaseModel):
    """A 'execution_success' message, indicating the workflow has completed successfully."""

    type: Literal["execution_success"]
    data: ExecutionSuccessData


class ExecutionStartMessage(BaseModel):
    """A 'execution_start' message, indicating the workflow has started."""

    type: Literal["execution_start"]
    data: ExecutionStartData


# --- Discriminated Union ---
# This type hint can represent any of the message types defined above. Pydantic
# will automatically use the 'type' field to determine which specific model
# to use for validation and parsing.

ComfyUIMessage = Annotated[
    Union[
        StatusMessage,
        ExecutingMessage,
        ExecutionCachedMessage,
        ExecutedMessage,
        ProgressMessage,
        ExecutionSuccessMessage,
        ExecutionStartMessage,
    ],
    Field(discriminator="type"),
]

ComfyUIMessageAdapter: TypeAdapter[ComfyUIMessage] = TypeAdapter(ComfyUIMessage)

# Example of how to use it:
#
# import ast
# from pydantic import TypeAdapter
#
# log_line = "{'type': 'progress', 'data': {'value': 1, 'max': 40, 'prompt_id': 'aa04a4ee-ad75-4134-9edc-ceb9f4cf21c9', 'node': '195'}}"
# log_dict = ast.literal_eval(log_line)
#
# MessageAdapter = TypeAdapter(ComfyUIMessage)
# parsed_message = MessageAdapter.validate_python(log_dict)
#
# print(parsed_message.type)
# # > progress
#
# print(parsed_message.data.model_dump_json(indent=2))
# # {
# #   "value": 1,
# #   "max": 40,
# #   "prompt_id": "aa04a4ee-ad75-4134-9edc-ceb9f4cf21c9",
# #   "node": "195"
# # }
